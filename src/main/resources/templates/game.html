<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game</title>
</head>
<body>
  <canvas id="myCanvas" width="500" height="500" style="border:1px solid #000;"></canvas>

  <script>
  
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");

    var x1 = 50, y1 = 50, x2 = 450, y2 = 450;
    
    
    class Dinamics {
        normalVectorToPlane(v1, v2) {
            return {
                x: v1.y * v2.z - v1.z * v2.y,
                y: v1.z * v2.x - v1.x * v2.z,
                z: v1.x * v2.y - v1.y * v2.x
            };
        }

        distance(point1, point2) {
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) +
                Math.pow(point1.y - point2.y, 2) +
                Math.pow(point1.z - point2.z, 2)
            );
        }

        unitaryVector(v) {
            let distance = this.distance({ x: 0, y: 0, z: 0 }, v)
            if (distance === 0) return { x: 0, y: 0, z: 0 };
            return ({
                x: v.x / distance,
                y: v.y / distance,
                z: v.z / distance
            })
        }

        rotate(alfa, rotationAxis, cartesiansCoordenates) {
            const cos = Math.cos(alfa), sin = Math.sin(alfa);
            const ux = rotationAxis.x, uy = rotationAxis.y, uz = rotationAxis.z;
            return cartesiansCoordenates.map((point) => {
                const x = point.x, y = point.y, z = point.z;
                return {
                    x: x * (cos + ux * ux * (1 - cos)) + y * (ux * uy * (1 - cos) - uz * sin) + z * (ux * uz * (1 - cos) + uy * sin),
                    y: x * (uy * ux * (1 - cos) + uz * sin) + y * (cos + uy * uy * (1 - cos)) + z * (uy * uz * (1 - cos) - ux * sin),
                    z: x * (uz * ux * (1 - cos) - uy * sin) + y * (uz * uy * (1 - cos) + ux * sin) + z * (cos + uz * uz * (1 - cos))
                };
            });
        }

        rotateXAxis(alfa, cartesiansCoordenates) {
            return this.rotate(alfa, { x: 1, y: 0, z: 0 }, cartesiansCoordenates)
        }

        rotateYAxis(alfa, cartesiansCoordenates) {
            return this.rotate(alfa, { x: 0, y: 1, z: 0 }, cartesiansCoordenates)
        }

        rotateZAxis(alfa, cartesiansCoordenates) {
            return this.rotate(alfa, { x: 0, y: 0, z: 1 }, cartesiansCoordenates)
        }

        rotationMatrix(v, m) {
            let ux = m.ux
            let uy = m.uy
            let uz = m.uz
            let vector = {
                x: ux.x * v.x + uy.x * v.y + uz.x * v.z,
                y: ux.y * v.x + uy.y * v.y + uz.y * v.z,
                z: ux.z * v.x + uy.z * v.y + uz.z * v.z
            }
            return vector
        }
    }

    class Ship extends Dinamics {

        userId = Math.random()

        R = {
            ux: { x: 1, y: 0, z: 0 },
            uy: { x: 0, y: 1, z: 0 },
            uz: { x: 0, y: 0, z: 1 }
        };

        shape = [
            { z: 2, x: 3, y: -2 },
            { z: -2, x: 3, y: -2 },
            { z: -3, x: 3, y: -1 },
            { z: -2, x: 3, y: -0 },
            { z: 2, x: 3, y: -0 },
            { z: 3, x: 3, y: -1 },
            { z: 2, x: 3, y: -2 },
            { z: 1, x: 12, y: -2 },
            { z: -1, x: 12, y: -2 },
            { z: -2, x: 3, y: -2 },
            { z: -5, x: 0, y: -2 },
            { z: -1, x: 12, y: -2 },
            { z: 1, x: 12, y: -2 },
            { z: 5, x: 0, y: -2 },
            { z: 2, x: 3, y: -2 },
            { z: 1, x: 12, y: -2 },
            { z: 2, x: 3, y: 0 },
            { z: -2, x: 3, y: 0 },
            { z: -1, x: 12, y: -2 },
        ];

        position = { x: 0.1, y: 0, z: 0 };
        velocity = { vx: 0, vy: 0, vz: 0 };
        direction = { x: 1, y: 0, z: 0 };
        view = { x: 0, y: 0, z: 0 };

        constructor(data) {
            super()
            if(data){
                this.position = data.position
                this.R = data.R
                this.userId = data.userId
            }
        }

        getData(){
            return {
                userId: this.userId,
                position: this.position,
                velocity: this.velocity,
                R: this.R
            }
        }

        updateShip(R, position){
            this.R = R
            this.position = position
        }

        actionShip(event) {
            switch (event.key) {
                case 'a': this.rotateYAxis(3); break;
                case 'd': this.rotateYAxis(-3); break;
                case 'w': this.rotateZAxis(3); break;
                case 's': this.rotateZAxis(-3); break;
                case 'q': this.rotateXAxis(-3); break;
                case 'e': this.rotateXAxis(3); break;
                case 'r': this.accelerate(3); break;
                case 'f': this.break(); break;
                default: break;
            }
            return this;
        }

        rotateXAxis(angle) {
            const rotationAngle = angle * 0.06;
            this.R.uy = this.rotate(rotationAngle, this.R.ux, [this.R.uy])[0];
            this.R.uz = this.rotate(rotationAngle, this.R.ux, [this.R.uz])[0];
            this.direction = this.rotate(rotationAngle, this.R.ux, [this.direction])[0];
            this.shape = this.rotate(rotationAngle, this.R.ux, this.shape);
        }

        rotateYAxis(angle) {
            const rotationAngle = angle * 0.03;
            this.R.ux = this.rotate(rotationAngle, this.R.uy, [this.R.ux])[0];
            this.R.uz = this.rotate(rotationAngle, this.R.uy, [this.R.uz])[0];
            this.direction = this.rotate(rotationAngle, this.R.uy, [this.direction])[0];
            this.shape = this.rotate(rotationAngle, this.R.uy, this.shape);
        }

        rotateZAxis(angle) {
            const rotationAngle = angle * 0.03;
            this.R.ux = this.rotate(rotationAngle, this.R.uz, [this.R.ux])[0];
            this.R.uy = this.rotate(rotationAngle, this.R.uz, [this.R.uy])[0];
            this.direction = this.rotate(rotationAngle, this.R.uz, [this.direction])[0];
            this.shape = this.rotate(rotationAngle, this.R.uz, this.shape);
        }

        moveShip() {
            this.position.x += this.velocity.vx;
            this.position.y += this.velocity.vy;
            this.position.z += this.velocity.vz;
            this.view.x = this.position.x - this.direction.x * 0.1;
            this.view.y = this.position.y - this.direction.y * 0.1;
            this.view.z = this.position.z - this.direction.z * 0.1;

            return this;
        }

        getPoints() {
            let points = []
            this.shape.forEach(point => {
                points.push([point.x + this.position.x, point.y + this.position.y, point.z + this.position.z])
            })
            return points
        }

        accelerate(amount) {
            const norm = this.distance(this.direction, { x: 0, y: 0, z: 0 })
            if (norm > 0) {
                this.velocity.vx += amount * (this.direction.x / norm) * 0.001;
                this.velocity.vy += amount * (this.direction.y / norm) * 0.001;
                this.velocity.vz += amount * (this.direction.z / norm) * 0.001;
            }
        }

        break() {
            const reductionFactor = 0.4;
            const hold = 0.0001;
            this.velocity.vx = Math.abs(this.velocity.vx) < hold ? 0 : this.velocity.vx * reductionFactor;
            this.velocity.vy = Math.abs(this.velocity.vy) < hold ? 0 : this.velocity.vy * reductionFactor;
            this.velocity.vz = Math.abs(this.velocity.vz) < hold ? 0 : this.velocity.vz * reductionFactor;
        }

        setShipHorientation(){
            this.shape = this.shape.map(point => {
                return this.rotationMatrix(point, this.R)
            })
        }
    }
    
    let ship = new Ship()

    function drawLine(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    
    function drawShip() {
    	for(let i = 0; i<ship.shape.length-1; i++) {
    		let x1 = ship.shape[i].x*10+250, x2 = ship.shape[i+1].x*10+250, y1 = ship.shape[i].y*10+250, y2 = ship.shape[i+1].y*10+250
    		drawLine(x1, y1, x2, y2)
    	}
    }
    
	drawShip();
    window.addEventListener("keydown", function(event) {
    	ctx.clearRect(0, 0, canvas.width, canvas.height);
    	ship = ship.actionShip(event)
    	drawShip()
    });
    
  </script>
</body>
</html>
