<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game</title>
</head>
<body>
<div>
  <canvas id="myCanvas" width="500" height="500" style="border:1px solid #000;"></canvas>
</div>

  <script>
  
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");

    var x1 = 50, y1 = 50, x2 = 450, y2 = 450;
    
    
    class Dinamics {
        normalVectorToPlane(v1, v2) {
            return {
                x: v1.y * v2.z - v1.z * v2.y,
                y: v1.z * v2.x - v1.x * v2.z,
                z: v1.x * v2.y - v1.y * v2.x
            };
        }

        distance(point1, point2) {
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) +
                Math.pow(point1.y - point2.y, 2) +
                Math.pow(point1.z - point2.z, 2)
            );
        }

        unitaryVector(v) {
            let distance = this.distance({ x: 0, y: 0, z: 0 }, v)
            if (distance === 0) return { x: 0, y: 0, z: 0 };
            return ({
                x: v.x / distance,
                y: v.y / distance,
                z: v.z / distance
            })
        }

        rotate(alfa, rotationAxis, cartesiansCoordenates) {
            const cos = Math.cos(alfa), sin = Math.sin(alfa);
            const ux = rotationAxis.x, uy = rotationAxis.y, uz = rotationAxis.z;
            return cartesiansCoordenates.map((point) => {
                const x = point.x, y = point.y, z = point.z;
                return {
                    x: x * (cos + ux * ux * (1 - cos)) + y * (ux * uy * (1 - cos) - uz * sin) + z * (ux * uz * (1 - cos) + uy * sin),
                    y: x * (uy * ux * (1 - cos) + uz * sin) + y * (cos + uy * uy * (1 - cos)) + z * (uy * uz * (1 - cos) - ux * sin),
                    z: x * (uz * ux * (1 - cos) - uy * sin) + y * (uz * uy * (1 - cos) + ux * sin) + z * (cos + uz * uz * (1 - cos))
                };
            });
        }

        rotateXAxis(alfa, cartesiansCoordenates) {
            return this.rotate(alfa, { x: 1, y: 0, z: 0 }, cartesiansCoordenates)
        }

        rotateYAxis(alfa, cartesiansCoordenates) {
            return this.rotate(alfa, { x: 0, y: 1, z: 0 }, cartesiansCoordenates)
        }

        rotateZAxis(alfa, cartesiansCoordenates) {
            return this.rotate(alfa, { x: 0, y: 0, z: 1 }, cartesiansCoordenates)
        }

        rotationMatrix(v, m) {
            let ux = m.ux
            let uy = m.uy
            let uz = m.uz
            let vector = {
                x: ux.x * v.x + uy.x * v.y + uz.x * v.z,
                y: ux.y * v.x + uy.y * v.y + uz.y * v.z,
                z: ux.z * v.x + uy.z * v.y + uz.z * v.z
            }
            return vector
        }
    }

    class Ship extends Dinamics {

        userId = Math.random()

        R = {
            ux: { x: 1, y: 0, z: 0 },
            uy: { x: 0, y: 1, z: 0 },
            uz: { x: 0, y: 0, z: 1 }
        };

        shape = [
            { x: -2, z: -3, y: 2 },
            { x: 2, z: -3, y: 2 },
            { x: 3, z: -3, y: 1 },
            { x: 2, z: -3, y: 0 },
            { x: -2, z: -3, y: 0 },
            { x: -3, z: -3, y: 1 },
            { x: -2, z: -3, y: 2 },
            { x: -1, z: -12, y: 2 },
            { x: 1, z: -12, y: 2 },
            { x: 2, z: -3, y: 2 },
            { x: 5, z: 0, y: 2 },
            { x: 1, z: -12, y: 2 },
            { x: -1, z: -12, y: 2 },
            { x: -5, z: 0, y: 2 },
            { x: -2, z: -3, y: 2 },
            { x: -1, z: -12, y: 2 },
            { x: -2, z: -3, y: 0 },
            { x: 2, z: -3, y: 0 },
            { x: 1, z: -12, y: 2 },
        ];


		shots = []
        position = { x: 0.1, y: 0, z: 0 };
        velocity = { vx: 0, vy: 0, vz: 0 };
        direction = { x: 0, y: 0, z: -1 };
        view = { x: 0, y: 0, z: 0 };

        constructor(data) {
            super()
            if(data){
                this.position = data.position
                this.R = data.R
                this.userId = data.userId
            }
        }

        getData(){
            return {
                userId: this.userId,
                position: this.position,
                velocity: this.velocity,
                R: this.R
            }
        }

        updateShip(R, position){
            this.R = R
            this.position = position
        }

        actionShip(event) {
            switch (event.key) {
                case 'a': this.rotateYAxis(3); break;
                case 'd': this.rotateYAxis(-3); break;
                case 'w': this.rotateXAxis(-3); break;
                case 's': this.rotateXAxis(3); break;
                case 'q': this.rotateZAxis(-3); break;
                case 'e': this.rotateZAxis(3); break;
                case 'r': this.accelerate(3); break;
                case 'p': this.doShot(); break;
                case 'f': this.break(); break;
                default: break;
            }
            return this;
        }

        rotateXAxis(angle) {
            const rotationAngle = angle * 0.06;
            this.R.uy = this.rotate(rotationAngle, this.R.ux, [this.R.uy])[0];
            this.R.uz = this.rotate(rotationAngle, this.R.ux, [this.R.uz])[0];
            this.direction = this.rotate(rotationAngle, this.R.ux, [this.direction])[0];
            this.shape = this.rotate(rotationAngle, this.R.ux, this.shape);
        }

        rotateYAxis(angle) {
            const rotationAngle = angle * 0.03;
            this.R.ux = this.rotate(rotationAngle, this.R.uy, [this.R.ux])[0];
            this.R.uz = this.rotate(rotationAngle, this.R.uy, [this.R.uz])[0];
            this.direction = this.rotate(rotationAngle, this.R.uy, [this.direction])[0];
            this.shape = this.rotate(rotationAngle, this.R.uy, this.shape);
        }

        rotateZAxis(angle) {
            const rotationAngle = angle * 0.03;
            this.R.ux = this.rotate(rotationAngle, this.R.uz, [this.R.ux])[0];
            this.R.uy = this.rotate(rotationAngle, this.R.uz, [this.R.uy])[0];
            this.direction = this.rotate(rotationAngle, this.R.uz, [this.direction])[0];
            this.shape = this.rotate(rotationAngle, this.R.uz, this.shape);
        }

        moveShip() {
            this.position.x += this.velocity.vx;
            this.position.y += this.velocity.vy;
            this.position.z += this.velocity.vz;
            this.view.x = this.position.x - this.direction.x * 0.1;
            this.view.y = this.position.y - this.direction.y * 0.1;
            this.view.z = this.position.z - this.direction.z * 0.1;

            return this;
        }

        getPoints() {
            let points = []
            this.shape.forEach(point => {
                points.push([point.x + this.position.x, point.y + this.position.y, point.z + this.position.z])
            })
            return points
        }

        accelerate(amount) {
            const norm = this.distance(this.direction, { x: 0, y: 0, z: 0 })
            if (norm > 0) {
                this.velocity.vx += amount * (this.direction.x / norm) * 0.001;
                this.velocity.vy += amount * (this.direction.y / norm) * 0.001;
                this.velocity.vz += amount * (this.direction.z / norm) * 0.001;
            }
        }

        break() {
            const reductionFactor = 0.4;
            const hold = 0.0001;
            this.velocity.vx = Math.abs(this.velocity.vx) < hold ? 0 : this.velocity.vx * reductionFactor;
            this.velocity.vy = Math.abs(this.velocity.vy) < hold ? 0 : this.velocity.vy * reductionFactor;
            this.velocity.vz = Math.abs(this.velocity.vz) < hold ? 0 : this.velocity.vz * reductionFactor;
        }

        setShipHorientation(){
            this.shape = this.shape.map(point => {
                return this.rotationMatrix(point, this.R)
            })
        }
        
        doShot(){
        	this.shots.push({
        		x:this.position.x,
        		y:this.position.y,
        		z:this.position.z,
        		vx:this.velocity.vx + this.direction.x*8,
        		vy:this.velocity.vy + this.direction.y*8,
        		vz:this.velocity.vz + this.direction.z*8
        	})
        	if(this.shots.length > 10){
        		this.shots.shift()
        	}
        }
        
        
        actionShot(){
        	this.shots = this.shots.map(shot => {
        		return({
        			x: shot.x + shot.vx,
        			y: shot.y + shot.vy,
        			z: shot.z + shot.vz,
					vx:shot.vx,
					vy:shot.vy,
					vz:shot.vz
        		})
        	})
        }
    }
    
    class Asteroid {
        position = {x:0, y:0, z:0}
        velocity = {vx:0, vy:0, vz:0}
        constructor(){
        	this.position.x = Math.random()*500
        	this.position.y = Math.random()*500
        	this.position.z = Math.random()*500
        	this.velocity.vx = Math.random()*2
        	this.velocity.vy = Math.random()*2
        	this.velocity.vz = Math.random()*2
        }
        move(){
        	this.position.x += this.velocity.vx
        	this.position.y += this.velocity.vy
        	this.position.z += this.velocity.vz
        	this.velocity.vx = this.changeDirection(this.position.x, this.velocity.vx)
        	this.velocity.vy = this.changeDirection(this.position.y, this.velocity.vy)
        	this.velocity.vz = this.changeDirection(this.position.z, this.velocity.vz)

        }
        
        changeDirection(p, v){
        	if(p > 700 || p < -700){ return -v }
        	return v
        }
        
    }
    
    let ship = new Ship()
    let asteroid = new Asteroid()
    let asteroids = []
    console.log(asteroid.position)

    function drawLine(x1, y1, x2, y2, width = 2) {
      ctx.beginPath();
  	  ctx.lineWidth = width
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    
    function drawSphere(x,y, size = 2){
    	ctx.beginPath()
    	ctx.arc(x,y,size,0,Math.PI*2)
    	ctx.fillStyle = 'black'
    	ctx.fill()
    	ctx.closePath()
    }
    
    function drawShip() {
    	for(let i = 0; i<ship.shape.length-1; i++) {
    		let x1 = ship.shape[i].x*5+250, x2 = ship.shape[i+1].x*5+250, y1 = ship.shape[i].y*5+250, y2 = ship.shape[i+1].y*5+250
    		drawLine(x1, y1, x2, y2)
    	}
    	for(let i = 0; i<ship.shots.length-1; i++) {
    		if(ship.shots[i].z > -300){
    		drawSphere(ship.shots[i].x+250, ship.shots[i].y+250, 3+0.01*ship.shots[i].z)	
    		}
    		//drawLine(ship.shots[i].x+250, ship.shots[i].y+250, ship.shots[i].x+ship.shots[i].x*1.1+250, ship.shots[i].y+ship.shots[i].y*1.1+250, 10+0.01*ship.shots[i].z)
    	}
    }
    
    function drawAsteroids(){
    	for(let i = 0; i<asteroids.length-1; i++) {
    		drawSphere(asteroids[i].position.x, asteroids[i].position.y, 5+1)	
    		
    	}
    }
    
    window.addEventListener("keydown", function(event) {
    	ship = ship.actionShip(event)
    	ctx.clearRect(0, 0, canvas.width, canvas.height);
    	drawShip()
    });
    
    let x=10, y=10
    function animate(){
    	ctx.clearRect(0, 0, canvas.width, canvas.height);
    	drawShip()
    	drawAsteroids()
    	ship.actionShot()
    	if(asteroids.length < 10){
    		asteroids.push(new Asteroid())
    	}
    	asteroids.forEach(asteroid => {
    		asteroid.move()
    	})
    	requestAnimationFrame(animate)
    }
    
    animate()
    
  </script>
</body>
</html>
